<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="SuPQ3DDNV0"><meta name="author" content="Minhui Zheng, mattzhengjob@gmail.com"><title>聊聊事件循环 · Minhui's blog</title><meta name="description" content="大家在面试中经常会被问到，浏览器事件循环和 node 事件循环有什么区别？
好问题。
简短说来，从执行结果来看，早期有区别，后来统一了。v11.0.0 (2018.10.23 release) 之后，没区别。
为什么？
看下面这段代码。
1234567setTimeout(() =&amp;gt; cons"><meta name="keywords" content="React,Next.js,Svelte,Web,HTML,JavaScript,CSS,Tailwind,Frontend,Angular"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no"><meta name="og:type" content="blog"><meta name="og:title" content="Minhui's blog"><meta name="og:description" content="I'm Minhui and I share my thoughts about reading, thinking, and web development."><meta name="og:image" content="https://zhengminhui.com/images/og-image-logo.png"><meta name="twitter:card" content="summary"><meta name="twitter:description" content="I'm Minhui and I share my thoughts about reading, thinking, and web development."><meta name="twitter:site" content="https://zhengminhui.com/"><meta name="twitter:creator" content="@minhui"><meta name="twitter:image" content="https://zhengminhui.com/images/og-image-logo.png"><meta name="renderer" content="webkit"><link type="image/png" href="https://zhengminhui.com/images/favicon16.png" rel="icon" size="16x16"><link type="image/png" href="https://zhengminhui.com/images/favicon32.png" rel="icon" size="32x32"><link href="/css/style.css" rel="stylesheet"><link href="/css/blog_basic.css" rel="stylesheet"><link href="/css/font-awesome.min.css" rel="stylesheet"><link type="application/atom+xml" href="/atom.xml" title="ATOM 1.0" rel="alternate"><script src="/_vercel/insights/script.js" defer=""></script><script src="https://www.googletagmanager.com/gtag/js?id=G-36J5NZ3PJY" async=""></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-36J5NZ3PJY');</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo.png" style="width:128px;"><h3 title=""><a href="/">Minhui's blog</a></h3><div class="description"><p>🖖 Live long and prosper.</p></div></div></div><ul class="social-links"><li><a href="https://github.com/zhengminhui" target="_blank"><i class="fa fa-github"></i></a></li><li><a href="http://instagram.com/wanzaiwanger" target="_blank"><i class="fa fa-instagram"></i></a></li><li><a href="http://weibo.com/alandwhatever" target="_blank"><i class="fa fa-weibo"></i></a></li><li><a href="https://twitter.com/wanzaiwanger" target="_blank"><i class="fa fa-twitter"></i></a></li><li><a href="https://zhengminhui.com/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></li></ul><div class="footer"><span>Theme by CaiCai & Ben</span><div class="by_farbox"><span>Proudly published with Hexo</span></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>聊聊事件循环</a></h3></div><div class="post-content"><p>大家在面试中经常会被问到，浏览器事件循环和 node 事件循环有什么区别？</p>
<p>好问题。</p>
<p>简短说来，<strong>从执行结果来看</strong>，早期有区别，后来统一了。v11.0.0 (2018.10.23 release) 之后，没区别。</p>
<p>为什么？</p>
<p>看下面这段代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout1&#x27;</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout2&#x27;</span>)</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise resolve&#x27;</span>))</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout3&#x27;</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout4&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>在浏览器中（chrome v89）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">timeout1</span><br><span class="line">timeout2</span><br><span class="line">promise resolve</span><br><span class="line">timeout3</span><br><span class="line">timeout4</span><br></pre></td></tr></table></figure>

<p>在 node 低于 v11.0.0环境中（在v6.11.2中验证，附赠一个<a target="_blank" rel="noopener" href="https://www.tutorialspoint.com/execute_nodejs_online.php">运行环境连接</a>）。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">timeout1</span><br><span class="line">timeout2</span><br><span class="line">timeout3</span><br><span class="line">timeout4</span><br><span class="line">promise resolve</span><br></pre></td></tr></table></figure>

<p>先看下node 11版本之前，node 是怎么执行的呢？</p>
<ol>
<li>执行完一个阶段的所有任务</li>
<li>执行完nextTick队列里的内容</li>
<li>执行完微任务队列里的内容</li>
</ol>
<p>所以，可以理解上面的结果，先打完了timeout ，最后才来resolve。</p>
<p>但是这些都已经旧船票了，已经登不上新时代的大船了。</p>
<p>接下来看看浏览器里的执行顺序，也就是node 11以后的执行顺序，从那时起，大伙就是相亲相爱一家人了。</p>
<p>通俗说来，在浏览器环境中，事件循环分3步（第3步就是回到最初的起点）：</p>
<ol>
<li>运行时在每个事件循环开始时，依次执行task queue 中的每个task，在执行task的过程中，如果又有新的task添加进来怎么办。没办法，先来后到，你只能等下一次循环了。 </li>
<li>第二步，当每一个 task 结束了，会去检查还有没有待执行的microtask，这里和 task 的显著区别是，他会等到microtask 队列为空才会停止。什么意思，如果一个微任务，不停的往微任务队列里添加新的微任务，那么，这一步骤就会头铁的进行下去。</li>
<li>microtask 执行完了，回到第1歩循环往复。</li>
</ol>
<p>言归正传，我们再来看下面这个例子（验证环境 chrome 89 &amp; node v14.16.0）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">4</span>)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// 4</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>);</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为了方便看一点，多 then 了几次。看看结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">undefined</span><br><span class="line">undefined</span><br><span class="line">undefined</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<p>可以看到，我们在then 中不断添加了新的 microtask 时，会继续执行下去，今日事今日毕。但是对于 task，不好意思，您往后稍稍。</p>
<p>v8博客上有张图，挺好。需要注意一点，图中 microtask 描述的是一个动态的过程，他还可以继续往 queue 里添加新的微任务，理解这点很重要。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b1a464bf2a64aafb65ab790fdbf4bde~tplv-k3u1fbpfcp-watermark.image" alt="micro-tasks-vs-tasks.png"></p>
<p>再来看下 node 中的event loop。</p>
<p>在这之前，解释一下为什么文章开头，我加粗的“从执行结果来看”。</p>
<p>本质上，事件循环是由宿主环境来实现，常见的宿主环境有web浏览器，nodejs，还有 Adobe Flash（没错，还有这个老哥，参见高程）。由于不同环境实现的不同，这也产生了这个古老的问题，“浏览器事件循环和 node 事件循环有什么区别？” 对于这种行为，这好吗？这不好。所以为了消除这种宿主环境之间执行的差异， node 11 之后改善了这个问题。</p>
<p>回到 node 官方文档，我们可以看到这么一张图流程图。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   ┌───────────────────────────┐</span><br><span class="line">┌─&gt;│           timers          │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │     pending callbacks     │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │       idle, prepare       │</span><br><span class="line">│  └─────────────┬─────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌─────────────┴─────────────┐      │   incoming:   │</span><br><span class="line">│  │           poll            │&lt;─────┤  connections, │</span><br><span class="line">│  └─────────────┬─────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌─────────────┴─────────────┐      └───────────────┘</span><br><span class="line">│  │           check           │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">└──┤      close callbacks      │</span><br><span class="line">   └───────────────────────────┘</span><br></pre></td></tr></table></figure>

<p>这张图有点抽象，换一张。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9aa3e314b504fcfb4e4d78d760c44bf~tplv-k3u1fbpfcp-watermark.image" alt="d502f94b-cc6c-4be7-ac8c-172897eefb05-original.png"></p>
<p>关于事件循环的解释，网上的解释数不胜数。感觉不少都是把官方文档的内容颠来倒去拼凑一下。除了官方文档以外，还有一篇文章觉得值得一读（上图就是我借来的），同样也附在最后的链接部分。在这里我就不展开，或许下次专门写一篇文章来记录一下自己的阅读心得。</p>
<p>再说点题外话，截止到今天（2021-3-16）， 对于 task, microtask 的官方用词和翻译还是 “任务 task  vs 微任务 microtask”。没有所谓的“宏任务”，也没有“macrotask” 这玩意什么事。用于谦于老爷的话说，这都不挨着。</p>
<p>关于宏任务&#x2F; macrotask，打开掘金知乎，包括英文环境，随便搜一搜，大把的文章，到处都在说，到处都在用。但是去查官方文档，mdn，v8 blog，html spec 等等，很难找到这个词出现的源头。一个没有源头的词，出现了人传人现象，在各种文章图片中出现，很有趣。如果有朋友知道这个词的来历，欢迎指点。</p>
<p>好了，文章到此为止，谢谢大家的阅读，欢迎讨论和指正。</p>
<p>接下来补充一些辅助阅读材料。</p>
<ol>
<li><p>mdn 文档。</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide">https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth">https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth</a></li>
</ol>
<p>一个小彩蛋，英文版的子标题， Run, JavaScript, run 是 Forrest Gump  里的经典台词，Run, Forrest , run!</p>
</li>
<li><p>Promise&#x2F;A+: <a target="_blank" rel="noopener" href="https://promisesaplus.com/#notes">https://promisesaplus.com/#notes</a>   </p>
<p>文档中关于 platform code 的解释中有这么一段话 <code>This can be implemented with either a “macro-task” mechanism such as setTimeout or setImmediate, or with a “micro-task” mechanism such as MutationObserver or process.nextTick</code>。 这也是我为数不多检索到明确使用“macro”的一处，当然还特意加上了引号。</p>
</li>
<li><p>html 文档：<a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/webappapis.html#concept-agent-event-loop">https://html.spec.whatwg.org/multipage/webappapis.html#concept-agent-event-loop</a></p>
</li>
<li><p>nodejs 文档：<a target="_blank" rel="noopener" href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/">https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/</a> </p>
</li>
<li><p>nodejs 事件循环：<a target="_blank" rel="noopener" href="https://www.voidcanvas.com/nodejs-event-loop/">https://www.voidcanvas.com/nodejs-event-loop/</a> ； 这篇文章的中文翻译：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/35918797">https://zhuanlan.zhihu.com/p/35918797</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://medium.com/the-node-js-collection/what-you-should-know-to-really-understand-the-node-js-event-loop-and-its-metrics-c4907b19da4c">What you should know to really understand the Node.js Event Loop</a></p>
</li>
<li><p>v8 博客关于任务，微任务的描述：<a target="_blank" rel="noopener" href="https://v8.dev/blog/fast-async#tasks-vs.-microtasks">https://v8.dev/blog/fast-async#tasks-vs.-microtasks</a></p>
</li>
<li><p>Jake Archibald 关于microtask 的文章：<a target="_blank" rel="noopener" href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/</a></p>
</li>
<li><p>关于task 名称的讨论。</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/302612139">https://www.zhihu.com/question/302612139</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/362096226">https://www.zhihu.com/question/362096226</a></li>
<li><a target="_blank" rel="noopener" href="https://weibo.com/1660579792/IkzWTc7FH">https://weibo.com/1660579792/IkzWTc7FH</a></li>
</ol>
</li>
<li><p>起因是看到这篇 issue <a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/26">浏览器和Node 事件循环的区别</a></p>
</li>
</ol>
<p>后记：</p>
<p>在写的过程中，看了不少材料，中文的，英文的，都有。发现可能只有1%的文章是经典，值得一读。其余的99%都是机械复制粘贴，不说人话。甚至都不知道写完之后作者自己会不会去看。所以当我整理的过程中，也在思考，怎么尽量把这件事用能被理解的方式，说清楚、讲明白，不仅是方便自己以后可以快速总结、回顾，也为不了解的朋友提供一些资料和思路。这也是写这篇文章的初衷。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-calendar"></i><span class="date">2021-04-07</span><i class="fa fa-tag"></i><a href="/categories/web/" title="web" class="tag">web </a><a href="/tags/javascript/" title="javascript" class="tag">javascript </a><a href="/tags/event-loop/" title="event loop" class="tag">event loop </a><a href="/tags/nodejs/" title="nodejs" class="tag">nodejs </a><a href="/tags/browser/" title="browser" class="tag">browser </a></div></div></div></div><div class="share"><div class="weibo"> <a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"> <a target="_blank" rel="noopener" href="https://twitter.com/intent/tweet?url=https://zhengminhui.com/2021/282aa8cf/&amp;text=聊聊事件循环%20·%20Minhui's blog" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2021/387a3740/" title="手机坏掉之后" class="btn">prev post</a></li><li class="next pagbuttons"><a role="navigation" href="/2021/curry-in-javascript/" title="聊聊柯里化" class="btn">next post</a></li></ul></div></div></div></div></div></body></html>